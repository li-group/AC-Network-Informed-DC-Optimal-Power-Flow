# Importing necessary packages
using BilevelJuMP
using JuMP
using Gurobi
using MAT
using MATLAB
using Ipopt
using Mosek
using MosekTools
using Printf
using PowerModels
using PGLib
using DataFrames
using CSV

# Defining paths to data files and working directory
path_data = "C:\\Users\\andre\\OneDrive\\Escritorio\\CodeDepurado300\\Modelos"
path_org = pwd()  # Saving the original working directory
cd(path_data)  # Changing to the data directory

# Selecting the test system
# system_name = "pglib_opf_case14_ieee"
# system_name = "pglib_opf_case30_ieee"
system_name = "pglib_opf_case57_ieee" 
# system_name = "pglib_opf_case118_ieee"
# system_name = "pglib_opf_case1354_pegase"

# Dictionary to store system cases
Cases = Dict()
Cases[system_name] = mat"run(append($system_name,'.m'))"

# Including the structure generation file
include("C:\\Users\\andre\\OneDrive\\Escritorio\\CodeDepurado300\\DCOPF\\CreateStructures_OPF.jl")

# Path to the .mat file generated by Matpower
path_data = "C:\\Users\\andre\\OneDrive\\Escritorio\\CodeDepurado300\\Matpower_CPF\\Generation_Matpower_$system_name.mat"

# Loading data from the .mat file
Data = matread(path_data)
PgAC = Data["DataMATPOWER"]["DispatchAC"][:,1:system.ngen]  # AC dispatch
Pd = Data["DataMATPOWER"]["Demand"][:,1:system.nbus]  # Energy demand
LMPS_AC = Data["DataMATPOWER"]["DualAC"] * 100  # Scaled dual marginal prices

# Other system variables
BBUS = Data["DataMATPOWER"]["BBUS"]
BF = Data["DataMATPOWER"]["BF"]
PBUSINJ = Data["DataMATPOWER"]["PBUSINJ"]
PFINJ = Data["DataMATPOWER"]["PFINJ"]

# Initialize variables for beta generation and time tracking
num_samples = size(Pd, 1)  # Number of samples
generated_beta = zeros(num_samples, system.nbus)  # Beta matrix initialization
time_beta = zeros(num_samples, 1)  # Time tracking for each sample
DualAP = zeros(num_samples, system.nbus)  # Dual variables for active power prices
cd(path_org)  # Returning to the original directory

# Reference bus selection
ref = findall(x -> x == 3, Bus.bustype)  # Finding reference bus
zero_indices = findall(x -> x == 0, Bus.Pd)  # Finding buses with zero demand
no_solution_sample = []  # List to track samples with no solution

# Generator index per bus
DispGen_bus = [Int[] for i in 1:system.nbus]
for i in 1:system.ngen
    a = convert(Int, system.GenBusnumber[i])
    push!(DispGen_bus[a], i)
end
GenBus = permutedims(Int.(system.GenBusnumber))[:, 1]


# Main loop for each sample
for step in 1:num_samples
    #try
    # Define Bilevel Model
    m_dc = BilevelModel()
    set_optimizer(m_dc, Gurobi.Optimizer)
    set_optimizer_attribute(m_dc, "BarHomogeneous", 1)
    set_optimizer_attribute(m_dc, "NonConvex", 2)
    set_optimizer_attribute(m_dc, "MIPGap", 1e-4)
    set_optimizer_attribute(m_dc, "TimeLimit", 20)
    set_optimizer_attribute(m_dc, "MIPFocus", 3)
    #set_optimizer_attribute(m_dc, MOI.Silent(), true)
    # set_optimizer(m_dc, KNITRO.Optimizer)
    BilevelJuMP.set_mode(m_dc, BilevelJuMP.StrongDualityMode())
    #Variables of Upper Problem
    @variable(Upper(m_dc), 10 >= beta[1:system.nbus] >= 0, start = 1)
    #Variables of Lower Problem
    @variable(Lower(m_dc), theta[1:system.nbus])
    @variable(Lower(m_dc), Pg[i = 1:system.ngen] == PgAC[step,i])
    # Fixing variables
    fix.(beta[zero_indices], 0; force=true)
    fix(theta[ref[1]], 0; force=true)

    # Objective Function Lower Problem
    @objective(Lower(m_dc), Min, sum(Gen_cost.ck1[i]*Pg[i] for i in 1:system.ngen))

    # Power balance constraint
    @constraint(Lower(m_dc), Balance_equation[k = 1:system.nbus], sum(Pg[m] for m in DispGen_bus[k]) ==
                             Pd[step,k]*beta[k] + Bus.Gs[k] + PBUSINJ[k] + sum(BBUS[k,j] * theta[j] for j in 1:system.nbus))
                             
    @constraint(Lower(m_dc), [k = 1:system.nbranch], sum(BF[k,i]*theta[i] for i = 1:system.nbus) + PFINJ[k] <= Branch.rateA[k])
    @constraint(Lower(m_dc), [k = 1:system.nbranch], sum(BF[k,i]*theta[i] for i = 1:system.nbus) + PFINJ[k] >=-Branch.rateA[k])

    # Active power bounds:
    @constraint(Lower(m_dc), [i in 1:system.ngen], Pg[i] <= Gen.Pmax[i])
    @constraint(Lower(m_dc), [i in 1:system.ngen], Pg[i] >= Gen.Pmin[i])

    # Upper-level objective: minimize beta and power mismatch
    @variable(Upper(m_dc), LMPs[k = 1:system.nbus], DualOf(Balance_equation[k]))
    # @objective(Upper(m_dc), Min, sum((beta[i])^2 for i in 1:system.nbus))
    @objective(Upper(m_dc), Min,
                                #   1e4/(system.ngen)*sum((Pg[i] - PgAC[l,i])^2 for i = 1:system.ngen)
    #                             # + 1e-2/(system.nbus)*sum((LMPs[i] - system.Sbase*LMPS_AC[l,i])^2 for i = 1:system.nbus)
                                + 1/(system.nbus)*sum((beta[i])^2 for i in 1:system.nbus)
                                )
    
                                # Revenue adequacy constraint
    @constraint(Upper(m_dc), sum(LMPs[k]*Pd[step,k] for k = 1:system.nbus) - sum(LMPs[GenBus[m]]*Pg[m]  for m = 1:system.ngen) >= 0)
    # Cost recovery for generators
    for k in 1:system.ngen
       i = convert(Int, system.GenBusnumber[k])
       @constraint(Upper(m_dc), LMPs[i]*Pg[k] - Gen_cost.ck1[k]*Pg[k] >= 0)
    end
    
    # Bounds on LMPs to speed up spatial B&B
    @constraint(Upper(m_dc), [i = 1:system.nbus], 0 <= LMPs[i] <= 1e5)

    # Solving the optimization problem
    start = time()
    optimize!(m_dc)
    elapsed = time() - start;

    # Storing results
    generated_beta[step,:]=JuMP.value.(beta)
    println(JuMP.value.(Pg))
    DualAP[step,:] = JuMP.value.(LMPs)
    time_beta[step]=elapsed

    # Check if solution exceeded time limit
    if time_beta[step] >= 20
        push!(no_solution_sample,l)
    end
    #catch
    #    push!(no_solution_sample,l)
    #end
    println("iteration:",step)
end

# Identify samples with no solution
for step in 1:num_samples
    if time_beta[step] == 0
        push!(no_solution_sample,step)
    end
end

# Filtering out samples with no solution
filtered_indices = unique(reshape(no_solution_sample, size(no_solution_sample,1), 1))

# Cleaning data based on filtered indices
clean_Pd = Data["DataMATPOWER"]["Demand"][setdiff(1:size(Data["DataMATPOWER"]["Demand"], 1), filtered_indices), :]
clean_PgAC = PgAC[setdiff(1:size(PgAC, 1), filtered_indices), :]
clean_LMPs = LMPS_AC[setdiff(1:size(LMPS_AC, 1), filtered_indices), :]
clean_beta  = generated_beta[setdiff(1:size(generated_beta , 1), filtered_indices), :]
clean_time_beta = time_beta[setdiff(1:size(time_beta, 1), filtered_indices), :]

# Storing cleaned results in a dictionary
Generation_MPCE = Dict()
Generation_MPCE["Beta"] = clean_beta 
Generation_MPCE["Time"] = clean_time_beta
Generation_MPCE["Demand"] = clean_Pd
Generation_MPCE["DispatchAC"] = clean_PgAC
Generation_MPCE["no_solution_sample"] =  filtered_indices
Generation_MPCE["Demand_Probe"] = Data["DataMATPOWER"]["Demand_Probe"]

# Writing the results to a .mat file
MAT.matwrite("Generation_MPCE_$system_name.mat", Generation_MPCE)

